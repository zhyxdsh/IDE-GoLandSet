<application>
  <component name="AppStorage">
    <histories>
      <item value="This so-called leftmost-first matching is the same semantics that Perl, Python, and other implementations use, although this package implements it without the expense of backtracking." />
      <item value="This so-called leftmost-first matching is the same semantics // that Perl, Python, and other implementations use, although this // package implements it without the expense of backtracking." />
      <item value="// CompilePOSIX is like Compile but restricts the regular expression // to POSIX ERE (egrep) syntax and changes the match semantics to // leftmost-longest. // // That is, when matching against text, the regexp returns a match that // begins as early as possible in the input (leftmost), and among those // it chooses a match that is as long as possible. // This so-called leftmost-longest matching is the same semantics // that early regular expression implementations used and that POSIX // specifies. // // However, there can be multiple leftmost-longest matches, with different // submatch choices, and here this package diverges from POSIX. // Among the possible leftmost-longest matches, this package chooses // the one that a backtracking search would have found first, while POSIX // specifies that the match be chosen to maximize the length of the first // subexpression, then the second, and so on from left to right. // The POSIX rule is computationally prohibitive and not even well-defined. // See https://swtch.com/~rsc/regexp/regexp2.html#posix for details." />
      <item value="missing argument to repetition operator: `?`" />
      <item value="// Compile parses a regular expression and returns, if successful, // a Regexp object that can be used to match against text. // // When matching against text, the regexp returns a match that // begins as early as possible in the input (leftmost), and among those // it chooses the one that a backtracking search would have found first. // This so-called leftmost-first matching is the same semantics // that Perl, Python, and other implementations use, although this // package implements it without the expense of backtracking. // For POSIX leftmost-longest matching, see CompilePOSIX." />
      <item value="record not found error, happens when haven't find any matched data when looking up with a struct" />
      <item value="duplicate" />
      <item value="Deprecated" />
      <item value="Inspection" />
      <item value="It returns the number of bytes written and any write error encountered." />
      <item value="Consignee" />
      <item value="Original" />
      <item value="appreciate" />
      <item value="assembly" />
      <item value="destination," />
      <item value="UNIQUE constraint failed: ind_product_render_template.render_template_id" />
      <item value=" UNIQUE constraint failed: ind_product_render_template.render_template_id " />
      <item value="Update Product Info Response" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="2" />
        <entry key="ENGLISH" value="2" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>